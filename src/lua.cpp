/*
 ** $Id: lua.c $
 ** Lua stand-alone interpreter
 ** See Copyright Notice in lua.h
 */

#define lua_c
#include <string_view>
#include <tuple>

#include <cstdlib>
#include <cstring>
#include <csignal>

#include "lua.h"

#include "lauxlib.h"
#include "lualib.h"

#if !defined(LUA_PROGNAME)
#define LUA_PROGNAME		"lua"
#endif

#if !defined(LUA_INIT_VAR)
#define LUA_INIT_VAR		"LUA_INIT"
#endif

#define LUA_INITVARVERSION	LUA_INIT_VAR LUA_VERSUFFIX


namespace {

    lua_State *globalL = nullptr;

    const char *progname = LUA_PROGNAME;


#if defined(LUA_USE_POSIX)   /* { */

    /*
     ** Use 'sigaction' when available.
     */
    void setsignal (int sig, void (*handler)(int)) {
        struct sigaction sa;
        sa.sa_handler = handler;
        sa.sa_flags = 0;
        sigemptyset(&sa.sa_mask);  /* do not mask any signal */
        sigaction(sig, &sa, nullptr);
    }

#else           /* }{ */

#define setsignal            signal

#endif                               /* } */


    /*
     ** Hook set by signal function to stop the interpreter.
     */
    void lstop (lua_State *L, lua_Debug *ar) {
        (void)ar;  /* unused arg. */
        lua_sethook(L, nullptr, 0, 0);  /* reset hook */
        luaL_error(L, "interrupted!");
    }


    /*
     ** Function to be called at a C signal. Because a C signal cannot
     ** just change a Lua state (as there is no proper synchronization),
     ** this function only sets a hook that, when called, will stop the
     ** interpreter.
     */
    void laction (int i) {
        int flag = LUA_MASKCALL | LUA_MASKRET | LUA_MASKLINE | LUA_MASKCOUNT;
        setsignal(i, SIG_DFL); /* if another SIGINT happens, terminate process */
        lua_sethook(globalL, lstop, flag, 1);
    }


    void print_usage (const char *badoption) {
        lua_writestringerror("%s: ", progname);
        if (badoption[1] == 'e' || badoption[1] == 'l') {
            lua_writestringerror("'%s' needs argument\n", badoption);
        }
        else {
            lua_writestringerror("unrecognized option '%s'\n", badoption);
        }
        lua_writestringerror(
                "usage: %s [options] [script [args]]\n"
                "Available options are:\n"
                "  -e stat   execute string 'stat'\n"
                "  -i        enter interactive mode after executing 'script'\n"
                "  -l mod    require library 'mod' into global 'mod'\n"
                "  -l g=mod  require library 'mod' into global 'g'\n"
                "  -v        show version information\n"
                "  -E        ignore environment variables\n"
                "  -W        turn warnings on\n"
                "  --        stop handling options\n"
                "  -         stop handling options and execute stdin\n"
                ,
                progname);
    }


    /*
     ** Prints an error message, adding the program name in front of it
     ** (if present)
     */
    void l_message (const char *pname, const char *msg) {
        if (pname) {
            lua_writestringerror("%s: ", pname);
        }
        lua_writestringerror("%s\n", msg);
    }


    /*
     ** Check whether 'status' is not OK and, if so, prints the error
     ** message on the top of the stack. It assumes that the error object
     ** is a string, as it was either generated by Lua or by 'msghandler'.
     */
    int report (lua_State *L, int status) {
        if (status != ThreadStatus::LUA_OK) {
            const char *msg = lua_tostring(L, -1);
            l_message(progname, msg);
            lua_pop(L, 1);  /* remove message */
        }
        return status;
    }


    /*
     ** Message handler used to run all chunks
     */
    int msghandler (lua_State *L) {
        const char *msg = lua_tostring(L, 1);
        if (msg == nullptr) {  /* is error object not a string? */
            if (luaL_callmeta(L, 1, "__tostring") &&  /* does it have a metamethod */
                    lua_type(L, -1) == LUA_TSTRING) {  /* that produces a string? */
                return 1;  /* that is the message */
            }
            else {
                msg = lua_pushfstring(L, "(error object is a %s value)", luaL_typename(L, 1));
            }
        }
        luaL_traceback(L, L, msg, 1);  /* append a standard traceback */
        return 1;  /* return the traceback */
    }


    /*
     ** Interface to 'lua_pcall', which sets appropriate message function
     ** and C-signal handler. Used to run all chunks.
     */
    int docall (lua_State *L, int narg, int nres) {
        int base = lua_gettop(L) - narg;  /* function index */
        lua_pushcfunction(L, msghandler);  /* push message handler */
        lua_insert(L, base);  /* put it under function and args */
        globalL = L;  /* to be available to 'laction' */
        (void)setsignal(SIGINT, laction);  /* set C-signal handler */
        int status = lua_pcall(L, narg, nres, base);
        (void)setsignal(SIGINT, SIG_DFL); /* reset C-signal handler */
        lua_remove(L, base);  /* remove message handler from the stack */
        return status;
    }


    void print_version() {
        (void)lua_writestring(LUA_COPYRIGHT, strlen(LUA_COPYRIGHT));
        lua_writeline();
    }


    /*
     ** Create the 'arg' table, which stores all arguments from the
     ** command line ('argv'). It should be aligned so that, at index 0,
     ** it has 'argv[script]', which is the script name. The arguments
     ** to the script (everything after 'script') go to positive indices;
     ** other arguments (before the script name) go to negative indices.
     ** If there is no script name, assume interpreter's name as base.
     ** (If there is no interpreter's name either, 'script' is -1, so
     ** table sizes are zero.)
     */
    void createargtable(lua_State *L, char **argv, int argc, int script) {
        int i, narg;
        narg = argc - (script + 1);  /* number of positive indices */
        lua_createtable(L, narg, script + 1);
        for (i = 0; i < argc; i++) {
            lua_pushstring(L, argv[i]);
            lua_rawseti(L, -2, i - script);
        }
        lua_setglobal(L, "arg");
    }


    int dochunk (lua_State *L, int status) {
        if (status == ThreadStatus::LUA_OK) {
            status = docall(L, 0, 0);
        }
        return report(L, status);
    }


    int dofile (lua_State *L, const char *name) {
        return dochunk(L, luaL_loadfile(L, name));
    }


    int dostring (lua_State *L, const char *s, const char *name) {
        return dochunk(L, luaL_loadbuffer(L, s, strlen(s), name));
    }


    /*
     ** Receives 'globname[=modname]' and runs 'globname = require(modname)'.
     ** If there is no explicit modname and globname contains a '-', cut
     ** the sufix after '-' (the "version") to make the global name.
     */
    int dolibrary (lua_State *L, char *globname) {
        char *suffix = nullptr;
        char *modname = strchr(globname, '=');
        if (modname == nullptr) {  /* no explicit name? */
            modname = globname;  /* module name is equal to global name */
            suffix = strchr(modname, *LUA_IGMARK);  /* look for a suffix mark */
        }
        else {
            *modname = '\0';  /* global name ends here */
            modname++;  /* module name starts after the '=' */
        }
        lua_getglobal(L, "require");
        lua_pushstring(L, modname);
        int status = docall(L, 1, 1);  /* call 'require(modname)' */
        if (status == ThreadStatus::LUA_OK) {
            if (suffix != nullptr) {  /* is there a suffix mark? */
                *suffix = '\0';  /* remove sufix from global name */
            }
            lua_setglobal(L, globname);  /* globname = require(modname) */
        }
        return report(L, status);
    }


    /*
     ** Push on the stack the contents of table 'arg' from 1 to #arg
     */
    int pushargs (lua_State *L) {
        if (lua_getglobal(L, "arg") != LUA_TTABLE) {
            luaL_error(L, "'arg' is not a table");
        }
        int n = static_cast<int>(luaL_len(L, -1));
        luaL_checkstack(L, n + 3, "too many arguments to script");
        int i = 1;
        for (; i <= n; i++) {
            lua_rawgeti(L, -i, i);
        }
        lua_remove(L, -i);  /* remove table from the stack */
        return n;
    }


    int handle_script (lua_State *L, char **argv) {
        const char *fname = argv[0];
        if (strcmp(fname, "-") == 0 && strcmp(argv[-1], "--") != 0) {
            fname = nullptr;  /* stdin */
        }
        int status = luaL_loadfile(L, fname);
        if (status == ThreadStatus::LUA_OK) {
            int n = pushargs(L);  /* push arguments to script */
            status = docall(L, n, LUA_MULTRET);
        }
        return report(L, status);
    }


    /* bits of various argument indicators in 'args' */
    enum ArgIndicators {
        has_error = 1, /* bad option */
        has_i = 2, /* -i */
        has_v = 4, /* -v */
        has_e = 8, /* -e */
        has_E = 16, /* -E */
    };

    /*
     ** Traverses all arguments from 'argv', returning a mask with those
     ** needed before running any Lua code or an error code if it finds any
     ** invalid argument. In case of error, 'first' is the index of the bad
     ** argument.  Otherwise, 'first' is -1 if there is no program name,
     ** 0 if there is no script name, or the index of the script name.
     */
    std::tuple<int, int> collectargs (char **argv) {
        int args = 0;
        if (argv[0] != nullptr) {  /* is there a program name? */
            if (argv[0][0]) {  /* not empty? */
                progname = argv[0];  /* save it */
            }
        }
        else {  /* no program name */
            return std::make_tuple(0, -1);
        }
        for (int i = 1; argv[i] != nullptr; i++) {  /* handle arguments */
            if (argv[i][0] != '-') { /* not an option? */
                return std::make_tuple(args, i);  /* stop handling options */
            }
            switch (argv[i][1]) {  /* else check option */
                case '-':  /* '--' */
                    if (argv[i][2] != '\0') {  /* extra characters after '--'? */
                        return std::make_tuple(ArgIndicators::has_error, i);  /* invalid option */
                    }
                    return std::make_tuple(args, i + 1);
                case '\0':  /* '-' */
                    return std::make_tuple(args, i);  /* script "name" is '-' */
                case 'E':
                    if (argv[i][2] != '\0') {  /* extra characters? */
                        return std::make_tuple(ArgIndicators::has_error, i);  /* invalid option */
                    }
                    args |= ArgIndicators::has_E;
                    break;
                case 'W':
                    if (argv[i][2] != '\0') { /* extra characters? */
                        return std::make_tuple(ArgIndicators::has_error, i);  /* invalid option */
                    }
                    break;
                case 'i':
                    args |= ArgIndicators::has_i;  /* (-i implies -v) *//* FALLTHROUGH */
                case 'v':
                    if (argv[i][2] != '\0') { /* extra characters? */
                        return std::make_tuple(ArgIndicators::has_error, i);  /* invalid option */
                    }
                    args |= ArgIndicators::has_v;
                    break;
                case 'e':
                    args |= ArgIndicators::has_e;  /* FALLTHROUGH */
                case 'l':  /* both options need an argument */
                    if (argv[i][2] == '\0') {  /* no concatenated argument? */
                        i++;  /* try next 'argv' */
                        if (argv[i] == nullptr || argv[i][0] == '-') {
                            return std::make_tuple(ArgIndicators::has_error, i);  /* no next argument or it is another option */
                        }
                    }
                    break;
                default:  /* invalid option */
                    return std::make_tuple(ArgIndicators::has_error, i);
            }
        }
        return std::make_tuple(args, 0); // no script name
    }


    /*
     ** Processes options 'e' and 'l', which involve running Lua code, and
     ** 'W', which also affects the state.
     ** Returns 0 if some code raises an error.
     */
    int runargs (lua_State *L, char **argv, int n) {
        for (int i = 1; i < n; i++) {
            int option = argv[i][1];
            lua_assert(argv[i][0] == '-');  /* already checked */
            switch (option) {
                case 'e':  case 'l': {
                                         int status;
                                         char *extra = argv[i] + 2;  /* both options need an argument */
                                         if (*extra == '\0') {
                                             extra = argv[++i];
                                         }
                                         lua_assert(extra != nullptr);
                                         status = (option == 'e')
                                             ? dostring(L, extra, "=(command line)")
                                             : dolibrary(L, extra);
                                         if (status != ThreadStatus::LUA_OK) {
                                             return 0;
                                         }
                                         break;
                                     }
                case 'W':
                                     lua_warning(L, "@on", 0);  /* warnings on */
                                     break;
            }
        }
        return 1;
    }


    int handle_luainit (lua_State *L) {
        const char *name = "=" LUA_INITVARVERSION;
        const char *init = getenv(name + 1);
        if (init == nullptr) {
            name = "=" LUA_INIT_VAR;
            init = getenv(name + 1);  /* try alternative name */
        }
        if (init == nullptr) return ThreadStatus::LUA_OK;
        else if (init[0] == '@')
            return dofile(L, init+1);
        else
            return dostring(L, init, name);
    }


    /*
     ** {==================================================================
     ** Read-Eval-Print Loop (REPL)
     ** ===================================================================
     */

#if !defined(LUA_PROMPT)
#define LUA_PROMPT		"> "
#define LUA_PROMPT2		">> "
#endif

#if !defined(LUA_MAXINPUT)
#define LUA_MAXINPUT		512
#endif


    /*
     ** lua_stdin_is_tty detects whether the standard input is a 'tty' (that
     ** is, whether we're running lua interactively).
     */
#if !defined(lua_stdin_is_tty)	/* { */

#if defined(LUA_USE_POSIX)	/* { */

#include <unistd.h>
#define lua_stdin_is_tty()	isatty(0)

#elif defined(LUA_USE_WINDOWS)	/* }{ */

#include <io.h>
#include <windows.h>

#define lua_stdin_is_tty()	_isatty(_fileno(stdin))

#else				/* }{ */

    /* ISO C definition */
#define lua_stdin_is_tty()	1  /* assume stdin is a tty */

#endif				/* } */

#endif				/* } */


    /*
     ** lua_readline defines how to show a prompt and then read a line from
     ** the standard input.
     ** lua_saveline defines how to "save" a read line in a "history".
     ** lua_freeline defines how to free a line read by lua_readline.
     */
#if !defined(lua_readline)	/* { */

#if defined(LUA_USE_READLINE)	/* { */

#include <readline/readline.h>
#include <readline/history.h>
#define lua_initreadline(L)	((void)L, rl_readline_name="lua")
#define lua_readline(L,b,p)	((void)L, ((b)=readline(p)) != nullptr)
#define lua_saveline(L,line)	((void)L, add_history(line))
#define lua_freeline(L,b)	((void)L, free(b))

#else				/* }{ */

#define lua_initreadline(L)  ((void)L)
#define lua_readline(L,b,p) \
    ((void)L, fputs(p, stdout), fflush(stdout),  /* show prompt */ \
     fgets(b, LUA_MAXINPUT, stdin) != nullptr)  /* get line */
#define lua_saveline(L,line)	{ (void)L; (void)line; }
#define lua_freeline(L,b)	{ (void)L; (void)b; }

#endif				/* } */

#endif				/* } */

    /*
     ** Return the string to be used as a prompt by the interpreter. Leave
     ** the string (or nil, if using the default value) on the stack, to keep
     ** it anchored.
     */
    const char *get_prompt (lua_State *L, int firstline) {
        if (lua_getglobal(L, firstline ? "_PROMPT" : "_PROMPT2") == LUA_TNIL)
            return (firstline ? LUA_PROMPT : LUA_PROMPT2);  /* use the default */
        else {  /* apply 'tostring' over the value */
            const char *p = luaL_tolstring(L, -1, nullptr);
            lua_remove(L, -2);  /* remove original value */
            return p;
        }
    }

    /* mark in error messages for incomplete statements */
    constexpr std::string_view EOFMARK {"<eof>"};
    constexpr std::size_t marklen = EOFMARK.size();


    /*
     ** Check whether 'status' signals a syntax error and the error
     ** message at the top of the stack ends with the above mark for
     ** incomplete statements.
     */
    int incomplete (lua_State *L, int status) {
        if (status == ThreadStatus::LUA_ERRSYNTAX) {
            size_t lmsg;
            const std::string_view msg = lua_tolstring(L, -1, &lmsg);
            if (lmsg >= marklen && (msg.substr(lmsg - marklen, msg.size()) == EOFMARK)) {
                lua_pop(L, 1);
                return 1;
            }
        }
        return 0;  /* else... */
    }


    /*
     ** Prompt the user, read a line, and push it into the Lua stack.
     */
    int pushline (lua_State *L, int firstline) {
        char buffer[LUA_MAXINPUT];
        char *b = buffer;
        size_t l;
        const char *prmt = get_prompt(L, firstline);
        int readstatus = lua_readline(L, b, prmt);
        if (readstatus == 0) {
            return 0;  /* no input (prompt will be popped by caller) */
        }
        lua_pop(L, 1);  /* remove prompt */
        l = strlen(b);
        if (l > 0 && b[l-1] == '\n') {  /* line ends with newline? */
            b[--l] = '\0';  /* remove it */
        }
        if (firstline && b[0] == '=') { /* for compatibility with 5.2, ... */
            lua_pushfstring(L, "return %s", b + 1);  /* change '=' to 'return' */
        }
        else {
            lua_pushlstring(L, b, l);
        }
        lua_freeline(L, b);
        return 1;
    }


    /*
     ** Try to compile line on the stack as 'return <line>;'; on return, stack
     ** has either compiled chunk or original line (if compilation failed).
     */
    int addreturn (lua_State *L) {
        const char *line = lua_tostring(L, -1);  /* original line */
        const char *retline = lua_pushfstring(L, "return %s;", line);
        int status = luaL_loadbuffer(L, retline, strlen(retline), "=stdin");
        if (status == ThreadStatus::LUA_OK) {
            lua_remove(L, -2);  /* remove modified line */
            if (line[0] != '\0')  /* non empty? */
                lua_saveline(L, line);  /* keep history */
        }
        else
            lua_pop(L, 2);  /* pop result from 'luaL_loadbuffer' and modified line */
        return status;
    }


    /*
     ** Read multiple lines until a complete Lua statement
     */
    int multiline (lua_State *L) {
        for (;;) {  /* repeat until gets a complete statement */
            size_t len;
            const char *line = lua_tolstring(L, 1, &len);  /* get what it has */
            int status = luaL_loadbuffer(L, line, len, "=stdin");  /* try it */
            if (!incomplete(L, status) || !pushline(L, 0)) {
                lua_saveline(L, line);  /* keep history */
                return status;  /* cannot or should not try to add continuation line */
            }
            lua_pushliteral(L, "\n");  /* add newline... */
            lua_insert(L, -2);  /* ...between the two lines */
            lua_concat(L, 3);  /* join them */
        }
    }


    /*
     ** Read a line and try to load (compile) it first as an expression (by
     ** adding "return " in front of it) and second as a statement. Return
     ** the final status of load/call with the resulting function (if any)
     ** in the top of the stack.
     */
    int loadline (lua_State *L) {
        int status;
        lua_settop(L, 0);
        if (!pushline(L, 1)) {
            return -1;  /* no input */
        }
        if ((status = addreturn(L)) != ThreadStatus::LUA_OK) { /* 'return ...' did not work? */
            status = multiline(L);  /* try as command, maybe with continuation lines */
        }
        lua_remove(L, 1);  /* remove line from the stack */
        lua_assert(lua_gettop(L) == 1);
        return status;
    }


    /*
     ** Prints (calling the Lua 'print' function) any values on the stack
     */
    void l_print (lua_State *L) {
        int n = lua_gettop(L);
        if (n > 0) {  /* any result to be printed? */
            luaL_checkstack(L, LUA_MINSTACK, "too many results to print");
            lua_getglobal(L, "print");
            lua_insert(L, 1);
            if (lua_pcall(L, n, 0, 0) != ThreadStatus::LUA_OK)
                l_message(progname, lua_pushfstring(L, "error calling 'print' (%s)",
                            lua_tostring(L, -1)));
        }
    }


    /*
     ** Do the REPL: repeatedly read (load) a line, evaluate (call) it, and
     ** print any results.
     */
    void doREPL (lua_State *L) {
        int status;
        const char *oldprogname = progname;
        progname = nullptr;  /* no 'progname' on errors in interactive mode */
        lua_initreadline(L);
        while ((status = loadline(L)) != -1) {
            if (status == ThreadStatus::LUA_OK) {
                status = docall(L, 0, LUA_MULTRET);
            }
            if (status == ThreadStatus::LUA_OK) {
                l_print(L);
            }
            else {
                report(L, status);
            }
        }
        lua_settop(L, 0);  /* clear stack */
        lua_writeline();
        progname = oldprogname;
    }

    /* }================================================================== */


    /*
     ** Main body of stand-alone interpreter (to be called in protected mode).
     ** Reads the options and handles them all.
     */
    int pmain (lua_State *L) {
        luaL_checkversion(L);  /* check that interpreter has correct version */

        int argc = static_cast<int>(lua_tointeger(L, 1));
        char **argv = static_cast<char **>(lua_touserdata(L, 2));
        const auto [args, script] = collectargs(argv);
        int optlim = (script > 0) ? script : argc; /* first argv not an option */
        if (args == ArgIndicators::has_error) {  /* bad arg? */
            print_usage(argv[script]);  /* 'script' has index of bad arg. */
            return 0;
        }
        if (args & ArgIndicators::has_v) {  /* option '-v'? */
            print_version();
        }
        if (args & ArgIndicators::has_E) {  /* option '-E'? */
            lua_pushboolean(L, 1);  /* signal for libraries to ignore env. vars. */
            lua_setfield(L, LUA_REGISTRYINDEX, "LUA_NOENV");
        }
        luaL_openlibs(L);  /* open standard libraries */
        createargtable(L, argv, argc, script);  /* create table 'arg' */
        lua_gc(L, LUA_GCRESTART);  /* start GC... */
        lua_gc(L, LUA_GCGEN, 0, 0);  /* ...in generational mode */
        if (!(args & ArgIndicators::has_E)) {  /* no option '-E'? */
            if (handle_luainit(L) != ThreadStatus::LUA_OK) { /* run LUA_INIT */
                return 0;  /* error running LUA_INIT */
            }
        }
        if (!runargs(L, argv, optlim)) {  /* execute arguments -e and -l */
            return 0;  /* something failed */
        }
        if (script > 0) {  /* execute main script (if there is one) */
            if (handle_script(L, argv + script) != ThreadStatus::LUA_OK) {
                return 0;  /* interrupt in case of error */
            }
        }
        if (args & ArgIndicators::has_i) { /* -i option? */
            doREPL(L);  /* do read-eval-print loop */
        }
        else if (script < 1 && !(args & (ArgIndicators::has_e | ArgIndicators::has_v))) { /* no active option? */
            if (lua_stdin_is_tty()) {  /* running in interactive mode? */
                print_version();
                doREPL(L);  /* do read-eval-print loop */
            }
            else {
                dofile(L, nullptr);  /* executes stdin as a file */
            }
        }
        lua_pushboolean(L, 1);  /* signal no errors */
        return 1;
    }
} // anonymous namespace

int main (int argc, char **argv) {
    lua_State *L = luaL_newstate();  /* create state */
    if (!L) {
        l_message(argv[0], "cannot create state: not enough memory");
        return EXIT_FAILURE;
    }
    lua_gc(L, LUA_GCSTOP);  /* stop GC while building state */
    lua_pushcfunction(L, &pmain);  /* to call 'pmain' in protected mode */
    lua_pushinteger(L, argc);  /* 1st argument */
    lua_pushlightuserdata(L, argv); /* 2nd argument */
    int status = lua_pcall(L, 2, 1, 0);  /* do the call */
    bool result = lua_toboolean(L, -1);  /* get result */
    report(L, status);
    lua_close(L);
    return (result && status == ThreadStatus::LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;
}

